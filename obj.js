//////////////////////////////////////////////////////////////////
/* Объекты в js - что это и что они из себя представляют  */
//объекты можно обозначить 2 способами 
let userqweqwqeData= new Object; //создание с помощью синтаксиса объекта
let userqweqwenfo = {}; // создание с помощью так называемого литерала объекта // 90% случаев гораздо более удобнее использовать этот способ 


//свойства объектов = ключ + значение 


let first="1";
let userCountry = {
    name:"Russia",                      //1 значение называется именем объекта или же его свойством 
    continent:"Eurasia", 
    eyars:"ochMnogo",                   //последняя запятай называется висячей и желательно ее использовать так как быстро можно будет что то поменять в объекте 
    "Russia federation":"My Country",    //паравильное написание пременной-ключа состоящего из 2 и более слов
    [first]:true,                      //передача имени в объект - то есть можем использовать внешнюю переменную

};

console.log(userCountry);                       // вызов всего объекта и показ всех данных которые в нем хранятся 
console.log(userCountry.continent);
console.log(userCountry["Russia federation"]); //правила ввыыедения в косносль если имя-ключ 2 и более слов
console.log(userCountry[first]);               //выведение переданной в объект переменной 


// преимущество квадратных скобок в том что мы можем получать данные из объекта , например определить переменную хранящюю свойство в себе / пример:
let babidjon = "name";
console.log(userCountry[babidjon]) //через точку это невозможно сделать

const habibi = {
    for:"352",      //в обектах можно использовать все, даже зарезервированые обозначение , не как в переменных в которых это исключенно;
    let:"515",
    1:"для имеени в объектах можно использовать даже числа"

}
console.log(habibi.let)
console.log(habibi[1])//только по фактам 1 это будет срока и ее можно выводить с "" :
console.log(habibi["1"])

//Символ -спец обозначение которое как бы скрывается от циклов и тд и оно там не появится 
//создание символа :
let gg=Symbol("gg");
let hh ={
    jj:"не символ",
    [gg]:"А вот это символ",
}
console.log(hh)
console.log("Переход к новому термену");
//////////////////////////////////////
//так же в объектах есть вложенность 
const gorodaAdresa ={
    mem:"ъуъ",
    adress:{
        ylitsa:"kolotuska",
        dom:"2",
        kvartira:"неопределенно",
    }

}
console.log(gorodaAdresa);
console.log(gorodaAdresa.adress)
console.log(gorodaAdresa.adress.kvartira)
///////////////////////////////////////////
//добавление свойств-ключей-имен в объект 
let obk ={
    namet:'valorant',

}

console.log(obk);

obk.game="its a game";

console.log(obk);

obk['time gameplay'] = '1k hour';
console.log(obk);

//если нам надо удаолить какое то свойство прописывем deleate - и оно бедет удаленно из объекта
delete obk.game;
console.log(obk)
//так же можем перезаписывать свойство объекта - всетак же прописываем путь до ключа который хотим изменить 
obk.namet = "frontend";
console.log(obk);

//копирование объекта - мы копируем так скажем не сам объект а его свойсво - то есть как бы просто ссылаемся на него ( был архив с папками и был ключ / мы копируем сам ключ но не архив)
let newObk=obk;
console.log(newObk);
newObk['time gameplay'] = "5k hour";
console.log(newObk);
console.log("истинный Obk");
console.log(obk)        ///при копировании данные так же изменяются ведь мы изменяем архив именно копируем , 
                        //а если мы хотим что бы один объект измениолся а другой остался изначальным то это уже называется дублированием 

//дублирование :
// Object.assign (куда(объект)-в какой объект в каоке место // что(1 свойство), что(2 свойство).... )
let dublObk = Object.assign({},obk)
dublObk.levl = "senior-pomidor";
dublObk['time gameplay'] = "4 eyars";
console.log(dublObk);
console.log("Отличия")
console.log(obk)

//Object.assign с помощью него можем добавлять новые свойства прямо со значением  
Object.assign(dublObk ,{ doxod:"420k в месяц" , gorod : { city:"Tyumen",car:"mercedes-benz"}});
console.log(dublObk);
//////////////////////////////////////////////////////








//тест на проверку существования того или иного значения :
if (dublObk.namet) {
console.log(dublObk.namet);                   ///////////////////////// почему не работае ?????????????????????????/
}










//проверка с помощью опциональной цепочки : главное что мы должны соблюдать такой синтаксис что бы у нас не загоралась красная ошибка если ключей нет это ?. ---
console.log(dublObk?.namet?.pc?.npc?.street)
//////////////////////////////////////////////
//проверка с помощью оператора in:
if("levl"/*имя пременной мы должны указывать независимо не от чего именно в "" */ in dublObk){
    console.log(dublObk.levl)
}  //если при проведение теста переменная не обнаружена то код не выводится вообще , не ошибки / абсолютно ничего

//когда использовать in в проверке ? тогда когда например у объекта в свойсвте как раз таки имеется значение undefinded -
/* let sdkfmsk ={ 
name = undefinded ;
ТОЛЬКО СВОЙСТВО IN ВЫВЕДЕТ В КОНСОЛЬ ЗНАЧЕНИЕ в других случаях код не выполниться / нельзя будет узнать что в name действительно есть занчение 
*/

console.log("for ..in цикл перебора данных !!!!!!!!!!!")
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//цикл For ... in используется для перебора значений 
for (let key /*key собирает все ключи - их значения в эту переменную*/ in dublObk){
    console.log(key) //выводит имена переменных 
    console.log(dublObk[key]) //а уже данный консоль лог выводит значения все переменных-ключей содержащихся в объекте
}
console.log("brrrrrrr");
for ( let key in dublObk.gorod){
    console.log(key);//ключи 
    console.log(dublObk.gorod[key])//значения ключей 
}



////////////////////////////
/* МЕТОДЫ ОБЪЕКТА */
//ФУНКЦИЯ ОБЪКТА ТАК ЖЕ МОЖЕТ БЫТЬ ПЕРЕМЕННОЙ //компанует все данные объекта в строчку 
let metod = {
    back :"2bb",
    alert:"в ахуе",
    holding :{
        countryaaa:"australia",
        director:"Nik Kud",

    },





    /*
    showInfosM: function (){
        console.log(`Состояние оценивается в ${this.back},все просто ${this.alert},Страна проживания на данный момент ${metod.holding.countryaaa} , имя:${metod.holding.director}`)


    }
    */
    //более которткая запись будет просто начинасться сразу объявления названия функции:
    //shouwRR(){
    //  console.log(`Состояние оценивается в ${this/*мы заменяем использование названия объекта из которого берется данные */.back},все просто ${this.alert},Страна проживания на данный момент ${metod/**/.holding.countryaaa} , имя:${metod/**/.holding.director}`)
   // }
//}
//metod.shouwRR();        //объявление функции все так же остается неизменным для ее выведения 








//не забываем про this - но нельзя его применять если есть еще одна вложеность функций ,так как this обращается к род элементу => а у стрелочной функции нет своего this 
//и он будет все так же обращатся к главному род элементу ( использовать внешний род элемент) и все будет выводится без ошибши :

shouwRR(){
    let show = () => console.log(`Состояние оценивается в ${this.back},все просто ${this.alert},Страна проживания на данный момент ${this.holding.countryaaa} , имя:${this.holding.director}`);
    show();}
}
metod.shouwRR();
////////////////////////////////////
//МЕТОД THIS ГОРАЗДО НАДЕЖНЕЕ И НАДО ИСПОЛЬЗОВАТЬ ЕГО ТАК КАК ПРИ ДУБЛИРОВАНИИ ОБЪЕКТА МОГУТ БЫТЬ ОШИБКИ / НАПРИМЕР ПРИ ОБНУЛЕНИИ СТАРОГО ОБЪЕКТА СО СТАРЫМ НАЗВАНИЕМ
//let fhfh = oldfhfh ;
//oldfhfh =null;
//fhfh.showкк();  в консоле при этом будет выводиться ошибка 


//А ЕСЛИ БУДЕМ ИСПОЛЬЗОВАТЬ THIS У НАС КАК БЫ НЕТ ПРИВЯЗКИ К ОБЪЕКТУ
//ХОТЬ ОН КАК БУДТО БЫ И УДАЛЕН У НАС С THIS ВСЕ РАВНО ВСЕ БУДЕТ РАБОТАТЬ 


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//ФУНКЦИИ КОНСТРУКЦИИ - СЛУЖАТ ДЛЯ ОБЪЯВЛЕНИЯ МНОЖЕСТВА ОДНОТИПНЫХ ОБЪЕКТОВ 
//во превых имя функции должно начинаться с большой буквы ( что было точно понятно что эта функция конструктор )
//а так же функция конструктор должна вызываться при помощи оператора - new -

function CreateObj(namee,rabota){

    //this неявно создает новый/пусной объект
    this.namee = namee,
    this.age = 20,
    this.rabota = rabota;
    //дальше работает return this, возвращает объекты  опять таки неявно 
    

}
console.log(new CreateObj("Никита","мини-прогер"));
console.log(new CreateObj("Егор","прогер"))




    
