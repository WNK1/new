//////////////////////////////////////////////////////////////////
/* Объекты в js - что это и что они из себя представляют  */
//объекты можно обозначить 2 способами 
let userqweqwqeData= new Object; //создание с помощью синтаксиса объекта
let userqweqwenfo = {}; // создание с помощью так называемого литерала объекта // 90% случаев гораздо более удобнее использовать этот способ 


//свойства объектов = ключ + значение 


let first="1";
let userCountry = {
    name:"Russia",                      //1 значение называется именем объекта или же его свойством 
    continent:"Eurasia", 
    eyars:"ochMnogo",                   //последняя запятай называется висячей и желательно ее использовать так как быстро можно будет что то поменять в объекте 
    "Russia federation":"My Country",    //паравильное написание пременной-ключа состоящего из 2 и более слов
    [first]:true,                      //передача имени в объект - то есть можем использовать внешнюю переменную

};

console.log(userCountry);                       // вызов всего объекта и показ всех данных которые в нем хранятся 
console.log(userCountry.continent);
console.log(userCountry["Russia federation"]); //правила ввыыедения в косносль если имя-ключ 2 и более слов
console.log(userCountry[first]);               //выведение переданной в объект переменной 


// преимущество квадратных скобок в том что мы можем получать данные из объекта , например определить переменную хранящюю свойство в себе / пример:
let babidjon = "name";
console.log(userCountry[babidjon]) //через точку это невозможно сделать

const habibi = {
    for:"352",      //в обектах можно использовать все, даже зарезервированые обозначение , не как в переменных в которых это исключенно;
    let:"515",
    1:"для имеени в объектах можно использовать даже числа"

}
console.log(habibi.let)
console.log(habibi[1])//только по фактам 1 это будет срока и ее можно выводить с "" :
console.log(habibi["1"]) //хоть так хоть так 

//Символ -спец обозначение которое как бы скрывается от циклов и тд и оно там не появится 
//создание символа :
let gg=Symbol("gg");
let hh ={
    jj:"не символ",
    [gg]:"А вот это символ",
}
console.log(hh)
console.log("Переход к новому термену");
//////////////////////////////////////
//так же в объектах есть вложенность 
const gorodaAdresa ={
    mem:"ъуъ",
    adress:{
        ylitsa:"kolotuska",
        dom:"2",
        kvartira:"неопределенно",
    }

}
console.log(gorodaAdresa);
console.log(gorodaAdresa.adress)
console.log(gorodaAdresa.adress.kvartira)
///////////////////////////////////////////
//добавление свойств-ключей-имен в объект 
let obk ={
    namet:'valorant',

}

console.log(obk);

obk.game="its a game";

console.log(obk);

obk['time gameplay'] = '1k hour';
console.log(obk);

//если нам надо удаолить какое то свойство прописывем deleate - и оно бедет удаленно из объекта
delete obk.game;
console.log(obk)
//так же можем перезаписывать свойство объекта - всетак же прописываем путь до ключа который хотим изменить 
obk.namet = "frontend";
console.log(obk);

//копирование объекта - мы копируем так скажем не сам объект а его свойсво - то есть как бы просто ссылаемся на него ( был архив с папками и был ключ / мы копируем сам ключ но не архив)
let newObk=obk;
console.log(newObk);
newObk['time gameplay'] = "5k hour";
console.log(newObk);
console.log("истинный Obk");
console.log(obk)        ///при копировании данные так же изменяются ведь мы изменяем архив именно копируем , 
                        //а если мы хотим что бы один объект измениолся а другой остался изначальным то это уже называется дублированием 

//дублирование :
// Object.assign (куда(объект)-в какой объект в каоке место // что(1 свойство), что(2 свойство).... )
let dublObk = Object.assign({},obk)
dublObk.levl = "senior-pomidor";
dublObk['time gameplay'] = "4 eyars";
console.log(dublObk);
console.log("Отличия")
console.log(obk)

//Object.assign с помощью него можем добавлять новые свойства прямо со значением  
Object.assign(dublObk ,{ doxod:"420k в месяц" , gorod : { city:"Tyumen",car:"mercedes-benz"}});
console.log(dublObk);
//////////////////////////////////////////////////////








//тест на проверку существования того или иного значения :
if (dublObk.namet) {
console.log(dublObk.namet);                   ///////////////////////// почему не работае ?????????????????????????/
}










//проверка с помощью опциональной цепочки : главное что мы должны соблюдать такой синтаксис что бы у нас не загоралась красная ошибка если ключей нет это ?. ---
console.log(dublObk?.namet?.pc?.npc?.street)
//////////////////////////////////////////////
//проверка с помощью оператора in:
if("levl"/*имя пременной мы должны указывать независимо не от чего именно в "" */ in dublObk){
    console.log(dublObk.levl)
}  //если при проведение теста переменная не обнаружена то код не выводится вообще , не ошибки / абсолютно ничего

//когда использовать in в проверке ? тогда когда например у объекта в свойсвте как раз таки имеется значение undefinded -
/* let sdkfmsk ={ 
name = undefinded ;
ТОЛЬКО СВОЙСТВО IN ВЫВЕДЕТ В КОНСОЛЬ ЗНАЧЕНИЕ в других случаях код не выполниться / нельзя будет узнать что в name действительно есть занчение 
*/

console.log("for ..in цикл перебора данных !!!!!!!!!!!")
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//цикл For ... in используется для перебора значений 
for (let key /*key собирает все ключи - их значения в эту переменную*/ in dublObk){
    console.log(key) //выводит имена переменных 
    console.log(dublObk[key]) //а уже данный консоль лог выводит значения все переменных-ключей содержащихся в объекте
}
console.log("brrrrrrr");
for ( let key in dublObk.gorod){
    console.log(key);//ключи 
    console.log(dublObk.gorod[key])//значения ключей 
}



////////////////////////////
/* МЕТОДЫ ОБЪЕКТА */
//ФУНКЦИЯ ОБЪКТА ТАК ЖЕ МОЖЕТ БЫТЬ ПЕРЕМЕННОЙ //компанует все данные объекта в строчку 
let metod = {
    back :"2bb",
    alert:"в ахуе",
    holding :{
        countryaaa:"australia",
        director:"Nik Kud",

    },





    /*
    showInfosM: function (){
        console.log(`Состояние оценивается в ${this.back},все просто ${this.alert},Страна проживания на данный момент ${metod.holding.countryaaa} , имя:${metod.holding.director}`)


    }
    */
    //более которткая запись будет просто начинасться сразу объявления названия функции:
    //shouwRR(){
    //  console.log(`Состояние оценивается в ${this/*мы заменяем использование названия объекта из которого берется данные */.back},все просто ${this.alert},Страна проживания на данный момент ${metod/**/.holding.countryaaa} , имя:${metod/**/.holding.director}`)
   // }
//}
//metod.shouwRR();        //объявление функции все так же остается неизменным для ее выведения 








//не забываем про this - но нельзя его применять если есть еще одна вложеность функций ,так как this обращается к род элементу => а у стрелочной функции нет своего this 
//и он будет все так же обращатся к главному род элементу ( использовать внешний род элемент) и все будет выводится без ошибши :

shouwRR(){
    let show = () => console.log(`Состояние оценивается в ${this.back},все просто ${this.alert},Страна проживания на данный момент ${this.holding.countryaaa} , имя:${this.holding.director}`);
    show();}
}
metod.shouwRR();
////////////////////////////////////
//МЕТОД THIS ГОРАЗДО НАДЕЖНЕЕ И НАДО ИСПОЛЬЗОВАТЬ ЕГО ТАК КАК ПРИ ДУБЛИРОВАНИИ ОБЪЕКТА МОГУТ БЫТЬ ОШИБКИ / НАПРИМЕР ПРИ ОБНУЛЕНИИ СТАРОГО ОБЪЕКТА СО СТАРЫМ НАЗВАНИЕМ
//let fhfh = oldfhfh ;
//oldfhfh =null;
//fhfh.showкк();  в консоле при этом будет выводиться ошибка 


//А ЕСЛИ БУДЕМ ИСПОЛЬЗОВАТЬ THIS У НАС КАК БЫ НЕТ ПРИВЯЗКИ К ОБЪЕКТУ
//ХОТЬ ОН КАК БУДТО БЫ И УДАЛЕН У НАС С THIS ВСЕ РАВНО ВСЕ БУДЕТ РАБОТАТЬ 


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//ФУНКЦИИ КОНСТРУКЦИИ - СЛУЖАТ ДЛЯ ОБЪЯВЛЕНИЯ МНОЖЕСТВА ОДНОТИПНЫХ ОБЪЕКТОВ 
//во превых имя функции должно начинаться с большой буквы ( что было точно понятно что эта функция конструктор )
//а так же функция конструктор должна вызываться при помощи оператора - new -

function CreateObj(namee,rabota){

    //this неявно создает новый/пусной объект
    this.namee = namee,
    this.age = 20,
    this.rabota = rabota;
    //дальше работает return this, возвращает объекты  опять таки неявно 
    

}
console.log(new CreateObj("Никита","мини-прогер"));
console.log(new CreateObj("Егор","прогер"))

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/* тип данных числа */
/* 
метод toString - возвращает строковое значение и представляет числа в той или иной системе исчисления 




*/

const sys = 222 ;
console.log(sys.toString(32));
console.log(sys.toString(16));
console.log(sys.toString(8));
console.log(sys.toString(2));



/// операторы округления 
/* 

Math.floor - округляет все в меньшую сторону 

Math.ceil - округление в большую сторону 

Math.round - округление до ближайшего целого ;

*/ 
//ПРИМЕРЫ 

const floor = -2.2;
const ceil = 7.5;
const round = 5.443;

console.log(Math.floor(floor));
console.log(Math.ceil(ceil));
console.log(Math.round(round));

/* но есть одно но при помощи только данного оператора округления , операция может быть не точной 
пример что нам надо округлить число 8.465 до сотых , если применить оператор round то он округлит его все ранво до 9 
как это исправить ??? ----------------
--------   1 способ это применить умножение и деление ((Math.round(round)*100)/100)
*/
//////////////////////////////////////

console.log(Math.round((round*100))/100);
// 2 способ 
/* использовать оператор toFixed но при этом нужно помнить что опертор будет приобразовывать данные в строку , которую мы должны будем преобразовать обратно в числовое значение 

*/ 
const toFixed = 9.9499435;
console.log(+toFixed.toFixed(5));
//можно обратно преобразовать в число либо с помощью унароного оператора + 
console.log(Number(toFixed.toFixed(6)));
//либо же указать тип данных number соответственно 





// в js сущетвует проблема неточных вычсилений она решается либо прописанием достаточно большой и трудной  функции которая есть в документации js
// или же с помошью Number.epsilon(очень маленькие числа)
// пример 
const epsilon = 2.006434 + Number.EPSILON ;
const eps = Math.round(epsilon * 100) / 100;
console.log(eps);


/// проверка значение isNaN и isFinite 
//сущетвует так как тот же самый NaN не буедт равен NaN и таких особенностей много 
console.log(Number(25 + "гаджишка делай"));
console.log(isNaN(25 + "гаджишка делай"));

//проверка Бесконечности 
console.log(isFinite(25)) //isfinite проверяет число и если оно обычное , то в консоль выводится true
console.log(isFinite("hi"));//так как это вообще строка выведится false 
console.log(isFinite(222/0));//бесконечность  соотвественно false

//если сталкиваться с числами у которых есть еденицы измерения например px то мы должны применять к ним функции 
//parsInt(целое число) & parsFloat (числа с плавуещей точкой)
 
const px = ('150.4561px');
console.log(parseInt(px));
console.log(parseFloat(px));

// функция math.random - возварщает случайные числа от 0 до 0.999999.... и тд
console.log(Math.random());



////
function brokenSite (){
    console.log(Math.random())
}

setTimeout (brokenSite , 00);

////////////
//строки  
/* перевод строки можно делать либо с помощью экранирование ( привет \nКак у тебя дела ?\n) \n- спец символ для преноса 
   либо же просто с помощью обратный ковычек (` привет
                                                какой сегодня день недели ? `)

///////////////////                                              
    спец симовол табуляции \t добавит отступ , так скажем он сделает в строке отступ как это делае tab 
    \ - с помощью которого можно сделать так что бы спец символы по типу \ "" появлялись в тексте 
    так же в строки можно вставлять символы эмодзи utf16 , utf32 
    */

console.log( `привет , давно не виделись ✅`);

// что бы узнать длинну строки нам нужно прописать функцию .lenght
const lengt = "Hey yo bro , whats up hahaha!";
console.log(lengt.length);


//что бы получить символ из строки мы просто указываем его позиции 
//что бы получить первый символ мы ппрописываем :
console.log(lengt[0])

//что бы получить последний символ не зная на какой он позиции 
console.log(lengt[lengt.length - 1]);




//если мы хотим получать абсолютно все символы которые у нас есть в переменной и они появились в консоле то пропишем следущей цикл: for ..of 
for (const alfavit  /*---- /*переменная в которую будет записываться получаемое значение */ of lengt){
    console.log(alfavit);
}
//изминения регистра .toUpperCase - вся строка заглавными буквами 
//.toLowerCase - вся смтрока с маленькими буквами 
//если мы хотим найти совпадение в строке то мы используем функцию indexOf - она напм укажет позицию где начинается совпадение и есть ли оно вообще 
//если его не будет то в лог выведется -1 
console.log(lengt.indexOf('ts'));

//методы includes / startsWith / endsWith 
//  includes это более совеменный метод поиска совпадений в строке он выводит true / false в зависимости есть или же нет совпадений 

console.log(lengt.includes('ey'));//true
console.log(lengt.includes('ey', 7));//false - так как ey на 7 позиции нет 

//starsWith - ищет подстроку в начале 
//endsWith - соответственно ищет подстроку в конце 


//нужно помнить что регистр имеет значение 
//пример 
/* 
const gh - Year
const hg - yE 
то мы сначала должны привести как нажу константу в нижний регистр так и что мы ищем в том числе к нижнему регистру 
console.log(gh.toLowerCase().includes(hg.toLowerCase()));
/*
*/
const gh = 'Year';
const hg = 'yE';

console.log(gh.toLowerCase().includes(hg.toLowerCase()));
//                ↑              ↑            ↑
//  1      соотвественно весь текс приводим в нижний регист       
//  2      начинаем поиск совпадений 
//  3      приводим то что мы пытаемся найти тоже в нижний регистр что бы небыло ошибок 


///////////////////////////////////
/* сравнение строк - слов 
* надо помнить что при сравнении мальенькая буква больше чем большая 
пример : */
console.log(`Сравнение строк`)
console.log('Абвг'>'абвг');
console.log('Никита'>'Егор');


// в JS существует много способов получение части строки но достаточно основного метода SLICE (start , end ) 
console.log(lengt.slice(22,29)); // указываем из какого диапазона позиций на нужно получить часть строки 
console.log(lengt.slice());//указываем если нам нужно получить часть строки/ весь диапозон из переменной 









///////////////////////////////////////////////////////////////////////////////////////////////////////////
/*                                           МАССИВЫ                                                    */
//создать массивы можно 2 способами
//1 способ 
let arr = new Array ();
//или же 
let arrs = [
    
    "1",
    '2', 
    '3', //как и в объктах указываем висячую запятую 

]; //что гораздо удобнее 

//в массивах может встречаться совсем разные типы данных 
let fmas = [
    '1',
    '6', 
    {
        array:2,
        jj:6,
        
    },
    true,
    function (){
        console.log((1.5))
    }
    

];
//так же сущетвует многомерные массивы 
let mngmas =[
    [1,2,3],
    [4,5,6],
    [7,8,9],
];

//что бы получить данные из массива нам нужно обратиться к позиции которая нас интересует , начинаются позиции с 0
console.log(mngmas[0]);

/*
let fmas = [
    '1',
    '6', 
    {
        array:2,
        jj:6,
        
    },
    true,
    function fun(){
        console.log(fun(1.5))
    }
    

];  */
//если я хочу обратиться например к объекту в данном массиве то следует делать следующем образом 
console.log(fmas[2].array) //в данном случае получаем данные только из array в объекте ;


//если я хочу вывести в лог данные функции ну или либо что она выводит / возвращает то следующем образом 
fmas[4]() //console.log когда мы хотим отобразить данные функции в массиве писать не нужно иначе буедт критическая ошибка 

//////////
/* что бы обратиться к конкретному лементу и его позиции в многомерном массиве в логе должен прописать*/
console.log(mngmas[2][2]);//где 0 - это позиция элемента а 2 это ключ и позиция  того элемента к которому я обратился 


/////////////////////////////////
//отличием массивов от объетов еще является то что в массивах есть свойство lenght
//что бы сразу получить длину массива и вывести его в отдельное значение надо прописать : 
console.log(mngmas.length);

///////////
function mnglen(){
    return mngmas.length;
};

console.log(`Длинна массива mngmas состовляет ${mnglen()} строки в многомерном исполнении`);
///////////
/* не забываем что массив являеться объектом соотвестнвенно и ведет себя так же */
//массив точног так же можно копировать и делегировать / все то же самое что и объектов
//при копирование массива можно изменять его длинну 
let newMng = mngmas ;
newMng.length = 1;
console.log(newMng);//напоминание что при копирование мы как бы просто создаем еще один ключ но все изменения так же будут внесены и в старый массив 
                    //а при делегировании мы иммено создаем новый массив / объект с такими же данными и но не как не связаны ;


                    ///last time 5:27 


function last(){
    console.log("last time 5:27");
};
setInterval(last ,1000);